use futures_util::{future, pin_mut, SinkExt, StreamExt};
use rsdrive::common::entity::{TransferControlMessage, TransferRequest};
use std::{
    env,
    fs::File,
    io::{BufReader, Read},
    path::PathBuf,
    sync::{Arc, Mutex},
};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio_tungstenite::{
    connect_async,
    tungstenite::{http::Request, protocol::Message},
};
use tracing::{debug, info, Level};
use tracing_subscriber::fmt::MakeWriter;

#[tokio::main]
async fn main() {
    let subscriber = tracing_subscriber::fmt()
        .compact()
        .with_file(true)
        .with_line_number(true)
        .with_thread_ids(true)
        .with_target(true)
        .with_max_level(Level::TRACE)
        .finish();
    tracing::subscriber::set_global_default(subscriber).unwrap();

    let addr = "ws://127.0.0.1:8080/api/ws";
    let url = url::Url::parse(addr).unwrap();

    let (stdin_tx, stdin_rx) = futures_channel::mpsc::unbounded();
    tokio::spawn(read_stdin(stdin_tx));

    let request = Request::builder()
        .uri(addr)
        .header("Host", url.host_str().unwrap())
        .header("Cookie", format!("auth-token={}", "1"))
        .header("Upgrade", "websocket")
        .header("Connection", "Upgrade")
        .header("Sec-WebSocket-Key", "SomeKey") // Automatically generated by the library
        .header("Sec-WebSocket-Version", "13")
        .body(())
        .unwrap();

    let (ws_stream, _) = connect_async(request).await.expect("Failed to connect");
    info!("WebSocket handshake has been successfully completed");

    let (mut sender, mut recv) = ws_stream.split();

    let filename = "/Users/neevek/dev/github/rsdrive/target/debug/client";
    let f = File::open(filename).expect("no file found");

    info!(">>>>>>>>>> haha file:{}", f.metadata().unwrap().len());
    let transfer_request = TransferRequest {
        file_hash: "TEST_FILE_HASH".to_string(),
        file_size: f.metadata().unwrap().len() as usize,
        file_name: "abc.jpg".to_string(),
        file_dir: "/sdcard/".to_string(),
    };

    sender.send(TransferControlMessage::Request(transfer_request).into()).await.unwrap();

    match recv.next().await {
        Some(Ok(Message::Text(msg))) => {
            info!(">>>>>>>>> haha recv text message:{msg}");
            let mut reader = BufReader::new(f);
            let mut buffer = [0u8; 4096];

            loop {
                // Read a block from the file into the buffer
                let bytes_read = reader.read(&mut buffer).unwrap();
                if bytes_read == 0 {
                    break;
                }
                std::thread::sleep(std::time::Duration::from_millis(1));
                debug!(">>>>>>> sending:{bytes_read}");
                sender.send(Message::binary(&buffer[..bytes_read])).await;
            }
        }
        e => {
            info!(">>>>>>>>>>> END: {e:?}");
        }
    }

    info!("quit!");

    // recv.for_each(|message| async move {
    //     match message {}
    //     // let data = message.unwrap().into_data();
    //     // tokio::io::stdout().write_all(&data).await.unwrap();
    // });

    // let stdin_to_ws = stdin_rx.map(Ok).forward(write);
    // let ws_to_stdout = {
    //     read.for_each(|message| async {
    //         let data = message.unwrap().into_data();
    //         tokio::io::stdout().write_all(&data).await.unwrap();
    //     })
    // };

    // pin_mut!(stdin_to_ws, ws_to_stdout);
    // future::select(stdin_to_ws, ws_to_stdout).await;
}

// Our helper method which will read data from stdin and send it along the
// sender provided.
async fn read_stdin(tx: futures_channel::mpsc::UnboundedSender<Message>) {
    let mut stdin = tokio::io::stdin();
    loop {
        let mut buf = vec![0; 1024];
        let n = match stdin.read(&mut buf).await {
            Err(_) | Ok(0) => break,
            Ok(n) => n,
        };
        buf.truncate(n);
        tx.unbounded_send(Message::binary(buf)).unwrap();
    }
}
