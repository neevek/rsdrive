use anyhow::{bail, Context, Result};
use futures_util::{SinkExt, StreamExt};
use rs_utilities::log_and_bail;
use tokio::net::TcpStream;
use tokio_tungstenite::{
    connect_async,
    tungstenite::{http::Request, Message},
    MaybeTlsStream, WebSocketStream,
};
use tracing::error;

use crate::common::entity::{TransferRequest, TransferResponse};

pub struct FileUploader {
    stream: Option<WebSocketStream<MaybeTlsStream<TcpStream>>>,
}

impl FileUploader {
    pub fn new() -> Self {
        Self { stream: None }
    }

    pub async fn connect(&mut self, addr: &str) -> Result<()> {
        // let addr = "ws://127.0.0.1:8080/api/ws";
        let url = url::Url::parse(addr)?;

        // let (stdin_tx, stdin_rx) = futures_channel::mpsc::unbounded();
        // tokio::spawn(read_stdin(stdin_tx));

        let request = Request::builder()
            .uri(addr)
            .header("Host", url.host_str().unwrap())
            .header("Cookie", format!("auth-token={}", "123"))
            .header("Upgrade", "websocket")
            .header("Connection", "Upgrade")
            .header("Sec-WebSocket-Key", "SomeKey") // Automatically generated by the library
            .header("Sec-WebSocket-Version", "13")
            .body(())
            .unwrap();

        self.stream = Some(connect_async(request).await?.0);

        println!("WebSocket handshake has been successfully completed");

        Ok(())
    }

    pub async fn upload(&mut self, req: TransferRequest) -> Result<()> {
        if let Some(stream) = &mut self.stream {
            let req_json = serde_json::to_string(&req)?;
            stream.send(Message::Text(req_json)).await?;
            let resp = match stream.next().await.with_context(|| "failed to receive from socket")? {
                Ok(Message::Text(text)) => serde_json::from_str::<TransferResponse>(text.as_str())?,
                Err(e) => {
                    log_and_bail!("failed to receive message: {e}");
                }
                _ => {
                    log_and_bail!("unexpected respnose");
                }
            };

            while let Some(message) = stream.next().await {
                match message {
                    Ok(Message::Text(text)) => {}
                    Err(e) => {
                        eprintln!("Error receiving message: {}", e);
                        break;
                    }
                    _ => {}
                }
            }
        }
        Ok(())
    }

    pub async fn close(&mut self) {
        if let Some(stream) = &mut self.stream {
            stream.close(None).await;
        }
    }
}
